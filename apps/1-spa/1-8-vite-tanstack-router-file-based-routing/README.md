# File-Based Routing with TanStack Router

This example demonstrates TanStack Router's file-based routing system, where routes are automatically generated from the file structure in the `src/routes/` directory, combined with route loaders for optimized data fetching.

## Key Learning Points

- **File-Based Routing**: Routes defined by file structure instead of programmatic configuration
- **Automatic Route Generation**: Router tree generated from `src/routes/` directory structure
- **Route File Naming**: Special naming conventions for dynamic routes and nested layouts
- **Generated Route Tree**: TanStack Router CLI generates `routeTree.gen.ts` automatically
- **Co-located Route Logic**: Each route file contains component, loader, and configuration
- **Route Loaders with File-Based Routes**: Same data loading patterns but organized by file structure

## File Structure and Route Mapping

```
src/routes/
├── __root.tsx           → Root layout component
├── index.tsx            → "/" route
├── posts.$id.tsx        → "/posts/[id]" dynamic route  
├── users.tsx            → "/users" route
└── users.$id.tsx        → "/users/[id]" dynamic route
```

## Code Examples

### Root Layout Route
```tsx
// src/routes/__root.tsx:1-17
export const Route = createRootRoute({
  component: () => (
    <AppLayout>
      <Outlet />
    </AppLayout>
  ),
  context: () => ({
    queryClient,
  }),
});
```

### Index Route with Loader
```tsx
// src/routes/index.tsx:7-14
export const Route = createFileRoute("/")({
  loader: ({ context: { queryClient } }) =>
    queryClient.ensureQueryData(postsQueryOptions),
  component: Index,
});

function Index() {
  const { data: posts } = useSuspenseQuery(postsQueryOptions);
  // Component code...
}
```

### Dynamic Route with Parameters
```tsx
// src/routes/posts.$id.tsx:9-21
export const Route = createFileRoute("/posts/$id")({
  loader: async ({ context: { queryClient }, params: { id } }) => {
    // First load the post
    const post = await queryClient.ensureQueryData(postQueryOptions(id));
    
    // Then load user and comments in parallel
    await Promise.all([
      queryClient.ensureQueryData(userQueryOptions(post.userId)),
      queryClient.ensureQueryData(postCommentsQueryOptions(id)),
    ]);
  },
  component: PostPage,
});
```

### Parameter Access in File-Based Routes
```tsx
// src/routes/posts.$id.tsx:25
function PostPage() {
  const { id: postId } = Route.useParams();
  // All data is already loaded by the route loader
  const { data: post } = useSuspenseQuery(postQueryOptions(postId));
  // Component code...
}
```

### Generated Route Tree
```tsx
// src/routeTree.gen.ts - Auto-generated by TanStack Router CLI
import { Route as rootRoute } from './routes/__root'
import { Route as UsersIdRoute } from './routes/users.$id'
import { Route as UsersRoute } from './routes/users'
import { Route as PostsIdRoute } from './routes/posts.$id'
import { Route as IndexRoute } from './routes/index'

// Route tree structure is automatically inferred from file system
const routeTree = rootRoute.addChildren([
  UsersIdRoute,
  UsersRoute, 
  PostsIdRoute,
  IndexRoute,
])
```

### Router Setup with Generated Tree
```tsx
// src/router.tsx:4-16
import { routeTree } from "./routeTree.gen";

export const createAppRouter = (queryClient: QueryClient) => {
  return createRouter({
    routeTree, // Uses generated route tree
    defaultPreload: "intent",
    defaultPreloadStaleTime: 0,
    scrollRestoration: true,
    context: {
      queryClient,
    },
  });
};
```

## File-Based Route Conventions

**Root Route**: `__root.tsx` - The top-level layout component
**Index Routes**: `index.tsx` - Matches the parent route exactly  
**Dynamic Routes**: `$param.tsx` - Creates `[param]` parameter
**Nested Routes**: `parent.child.tsx` - Creates nested route structure
**Layout Routes**: Directory with `index.tsx` creates layout + children

## Benefits of File-Based Routing

**1. Intuitive Organization**
- Route structure matches URL structure
- Easy to find and organize route-related code
- No separate route configuration to maintain

**2. Co-located Logic** 
- Component, loader, and route config in same file
- Related code stays together
- Easier to maintain and refactor

**3. Automatic Route Generation**
- No manual route tree configuration  
- CLI automatically generates route tree from file structure
- Reduces boilerplate and potential errors

**4. Type Safety Maintained**
- Full TypeScript support with generated types
- Parameter types inferred from file names
- Same type safety as code-based routing

## Comparison with Code-Based Routing (1-7)

**Code-Based (1-7):**
```tsx
// All routes defined in single AppRoutes.tsx file
const postRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/posts/$id", 
  loader: async ({ context, params }) => { /* ... */ },
  component: PostPage,
});
```

**File-Based (1-8):**
```tsx
// Each route in its own file: src/routes/posts.$id.tsx
export const Route = createFileRoute("/posts/$id")({
  loader: async ({ context, params }) => { /* ... */ },
  component: PostPage,
});
```

File-based routing provides the same powerful data loading capabilities as code-based routing, but with better organization and developer experience through conventional file structure.